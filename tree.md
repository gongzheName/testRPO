
### 前期准备
1. 技术选型(hooks+immutable+redux)
2. 拆分需求(性能优化是核心: 虚拟加载 + immutable, 树的递归遍历和增删改查; 支持主流浏览器: ie/Chrome/Safari/Firefox)
3. 目录结构

### 编码
1. 遇到的问题以及解决方案   
1.1  如何将redux和hooks关联: useReducer      
1.2  只渲染当前可视窗口的数据: 通过窗口顶部数据的索引确定   
1.3  渲染当前窗口数据: [窗口顶部数据索引 start, start + 窗口可容纳的树形节点 visibleCount]   
1.4  数据截取: 最开始用的数组的slice方法, 后续变更成惰性加载(Seq.take)
1.5  父节点收起, 不渲染其下所有子节点(防止无用渲染耗费时间): 通过展开/收起 标志位判断   
1.6  新增和删除操作, 每次都会重新递归整个树形数据: 这种操作不太划算, 所以暂存数据, 等到必须要递归的时候才去重新递归   

2. 相对较好的点   
2.1  增删操作, 并没有递归整个数组; 而是修改最小变化范围下的数据   
2.2  数据递归操作, 是根据当前树节点的展开收起状态来递归   
2.3  骨架屏   
2.4  hooks组件的ref向下传递

3. 收获   
3.1  命名语义化, 不要追求简洁而丢弃代码可读性   
3.2  注释规范并给出最小可运行单元   
3.3  思考边界条件对代码造成的影响; 思考给代码的进一步瘦身(包括但不限于性能优化, 方法剥离等等)

4. 不足   
4.1  设想的必须要递归的场景不够靠后   
4.2  对immutable的了解还不够深入(比如Seq)   
4.3  存在滥用hooks的情况   
4.4  使用useMemo(数据缓存和性能优化)时, 容易浪费资源